Я реализовал функции для парсинга текста программ, использующие аппликативный парсинг. Добавил работу с атомами и cons-ячейками, арифметические операции, сравнения, использование quote.

Парсинг текста программы осуществляется с использованием библиотеки Megaparsec. Научился пользоваться *Text.Megaparsec.Char.Lexer as L*, например, для парсинга и игнорирования комментариев и пробелов.

Научился пользоваться:
<|> для комбинирования вычислений, возвращая первое успешное значение.
<$> для применения функции к значению, обернутому в контекст. 
mapM_ для того чтобы пройтись по каждой строчке из файла с программой.  

Для условий сделал следующее:
ifExpr :: Parser SExpr
ifExpr = do
    _ <- string "(if"
    cond <- space1 *> expr
    thenBranch <- space1 *> expr
    elseBranch <- space1 *> expr
    _ <- char ')'
    return $ If cond thenBranch elseBranch

т.е. воспользовался монадическим синтаксисом *do* и парсил по частям тело
аналогично для всех остальных выражений

научился пользоваться оператором *>, например
char 't' *> pure True
здесь я делаю парсинг инпута, если парсится 't', то я в оператор добавляю True
pure — это функция, которая помещает значение в контекст.


# TODO
loop (1)
макросы (1)
работа с переменными (1)
работа со строками (1)
c[ad]+r-like функции для доступа к ячейке по произвольному пути (1)
работа с исключениями (2)
конкурентное программирование (3)
опциональная строгая система типов, проверяемая перед запуском (4)
json + api на типах + htmx = веб-интерпретатор (6)

всего 20
