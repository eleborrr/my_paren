Я реализовал функции для парсинга текста программ, использующие аппликативный парсинг. Добавил работу с атомами и cons-ячейками, арифметические операции, сравнения, использование quote.

Парсинг текста программы осуществляется с использованием библиотеки Megaparsec. Научился пользоваться *Text.Megaparsec.Char.Lexer as L*, например, для парсинга и игнорирования комментариев и пробелов.

Научился пользоваться:
<|> для комбинирования вычислений, возвращая первое успешное значение.
<$> для применения функции к значению, обернутому в контекст. 
mapM_ для того чтобы пройтись по каждой строчке из файла с программой.  

Для условий сделал следующее:
ifExpr :: Parser SExpr
ifExpr = do
    _ <- string "(if"
    cond <- space1 *> expr
    thenBranch <- space1 *> expr
    elseBranch <- space1 *> expr
    _ <- char ')'
    return $ If cond thenBranch elseBranch

т.е. воспользовался монадическим синтаксисом *do* и парсил по частям тело
аналогично для всех остальных выражений

научился пользоваться оператором *>, например
char 't' *> pure True
здесь я делаю парсинг инпута, если парсится 't', то я в оператор добавляю True
pure — это функция, которая помещает значение в контекст.


# TODO
loop (1)

макросы (1)

*работа с переменными (1)*
добавил поддержку окружения (Env). Это по сути словарь, который сохраняет в себе значения. Он прокидывается с каждым eval для строк

*работа со строками (1)*
добавил парсинг в StringLiteral строк, которые заключены в кавычки.
Реализовал все функции из списка.
string check просто проверяет тип выражения.
string equal сначала проверяет тип выражения, потом сравнивает значения StringLiteral
в Substring воспользовался функциями из Prelude (take и drop)
для объединения строк пользовался foldl

*c[ad]+r-like функции для доступа к ячейке по произвольному пути (1)*
анализируется c[ad]+r на последовательность операций в функции parseCadrLike.
в функции buildCadrExpr собирается правильная последовательность операций.

работа с исключениями (2)

конкурентное программирование (3)

опциональная строгая система типов, проверяемая перед запуском (4)

json + api на типах + htmx = веб-интерпретатор (6)

всего 20

# P.S.
переработал весь проект, потому что ничего не получалось расширить.
добавил предобработку входных данных (tokenizer), который превращает строку в массив литералов.
далее делаю сочетаю аппликативный парсинг (<|> в parseSExpr)  монадический парсинг (do в частных парсерах).
Например, для (+ 2 2) сначала вызывается parseList, который принимает скобку, и отправляет тело дальше парситься.
функция парсинга подбирается по входящему токену, токен проверяется в функции token.
все атомы и специальные формы в итоге собираются в соответствующий SExpr. В остальном схоже с предыдущим вариантом.
все это в итоге собирается в синтаксическое дерево.

интерпретатор работает с этим синтаксическим деревом. Для каждого типа SExpr реализовал рекурсивную функцию eval.
